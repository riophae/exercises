#### 3.2

给你一个链表 L 和另一个链表 P，它们包含以升序排列的整数。操作 `PrintLots(L, P)` 将打印 L 中那些由 P 所指定的位置上的元素。例如，如果 `p = 1, 3, 4, 6`，那么，L 中的第1、第3、第4和第6个元素被打印出来。写出过程 `PrintLots(L, P)`。你应该只使用基本的表操作。该过程的运行时间是多少？

#### 3.3

通过只调整指针（而不是数据）来交换两个相邻的元素，使用

a. 单链表。  
b. 双链表。

#### 3.4

给定两个已排序的表 L<sub>1</sub> 和 L<sub>2</sub>，只使用基本的表操作编写计算 L<sub>1</sub>∩L<sub>2</sub>。

#### 3.5

给定两个已排序的表 L<sub>1</sub> 和 L<sub>2</sub>，只使用基本的表操作编写计算 L<sub>1</sub>∪L<sub>2</sub>。

#### 3.6

编写将两个多项式相加的函数。不要毁坏输入数据。用一个链表实现。如果这两个多项式分别有 M 项和 N 项，那么你的程序的时间复杂度是多少？

#### 3.7

编写一个函数将两个多项式相乘，用一个链表实现。你必须保证输出的多项式按幂次排列并且最多有一项为任意幂。


a. 给出以 O(M<sup>2</sup>N<sup>2</sup>) 时间求解该问题的算法。  
b.(\*) 编写一个以 O(M<sup>2</sup>N) 时间执行乘法的程序，其中 M 是具有较少项数的多项式的项数。  
c.(\*) 编写一个以 O(MNlog(MN)) 时间执行乘法的程序。  
d. 上面哪个的时间界最好？  

#### 3.8

编写一个程序，输入一个多项式 F(X)，计算出 (F(X))<sup>P</sup>。你的程序的时间复杂度是多少？至少再提出一种对 F(X) 和 P 的某些可能的选择具有竞争性的解法。
